user                            www;
worker_processes                auto; # it will be determinate automatically by the number of core
daemon                          off; # Enable the master process to run in the foreground
#error_log                       /var/log/nginx/error.log warn;
error_log                       /dev/stderr warn; #Send error logs to standard error 

#pid                             /var/run/nginx/nginx.pid; # it permit you to use rc-service nginx reload|restart|stop|start

events {
    worker_connections          1024;
}

http {
    include                     /etc/nginx/mime.types;
    default_type                application/octet-stream;
    sendfile                    on;
    access_log                  /var/log/nginx/access.log;
    keepalive_timeout           3000;
    server {
        listen                  443 ssl; # Listen for HTTPS on port 443
        listen                  [::]:443 ssl; # Listen on IPv6 as well

        ssl_certificate         /etc/nginx/ssl/nginx.crt;      # Path to certificate inside the container
        ssl_certificate_key     /etc/nginx/ssl/nginx.key;      # Path to private key inside the container

        ssl_protocols           TLSv1.2 TLSv1.3;
        ssl_ciphers             HIGH:!aNULL:!MD5;

        root                    /www; # Where your index.html or index.php is located
        index                   index.php index.html index.htm; 
        # Placing index.php first ensures that if a directory is requested and 
        # both index.php and index.html (or other index files) exist within that directory, 
        # WordPress's index.php is always given precedence and executed, allowing WordPress 
        # to take control of the request and render the appropriate dynamic content.
        server_name             localhost luicasad.42.fr; 
        client_max_body_size    8m; # match post_max_size in php.ini to Preventing Resource Exhaustion (DoS Protection):  
        error_page              500 502 503 504  /50x.html;
        error_page              497 =400 /bad_request_ssl.html; # =400 ensures the client still sees 400
        # Custom error page for 404 Not Found
        error_page              404 /page_not_found.html;
        location = /50x.html {
              root              /var/lib/nginx/html;
        }
        
        # --------------------------------------------------------------------
        # IMPORTANT: Static files MUST be handled BEFORE the location / block
        # --------------------------------------------------------------------
        location ~* \.(css|js|gif|jpe?g|png|woff|woff2|ttf|eot|svg|ico)$ {
            expires 30d; # Cache for a month
            add_header Cache-Control "public, no-transform";
            try_files $uri =404; # Serve file directly or 404
            # Add this to prevent accidental redirects or internal processing
            # It should already be handled by try_files but good to be explicit
            # access_log off; # Optional: Don't log access for these files
        }
        # --------------------------------------------------------------------
        # PHP files MUST be handled BEFORE the general location / block
        # --------------------------------------------------------------------

        # You'd typically use ~* when you want to handle file extensions or parts of a URL 
        # without worrying about the client's capitalization.
        # ~*: This is the operator for a case-insensitive regular expression match. either .php or . PHP
        # ~ : This is the operator for a case-  sensitive regular expression match. only .php
        location ~* \.php$ {
        # Ensure the file exists before passing to PHP-FPM
        try_files $uri =404;

        # Forward requests to the contentserver container's IP and PHP-FPM port
        fastcgi_pass 192.168.1.3:9000;

        # Include standard FastCGI parameters
        include fastcgi_params;

        # Set the SCRIPT_FILENAME to the actual path in the contentserver container
        # This tells PHP-FPM the absolute path to the PHP script it needs to execute 
        # within its own container. 
        # $document_root will be /www
        # $fastcgi_script_name will be the requested PHP file (e.g., /index.php).
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        }

        # --------------------------------------------------------------------
        # WordPress Permalinks / General Fallback - This must be LAST
        # --------------------------------------------------------------------

        # This is the crucial line for WordPress permalinks
        # $uri: Nginx first tries to serve the request as a literal file 
        # (e.g., if you request /image.jpg, it looks for /www/image.jpg).
        # $uri/: If $uri isn't found, Nginx then tries to serve it as a directory 
        # (e.g., if you request /my-folder/, it looks for /www/my-folder/index.html or index.php based on index directive).
        # /index.php?$args;: If neither a direct file nor a directory is found, Nginx internally redirects the request 
        # to /index.php and passes all original query arguments (?$args). This is what allows WordPress to take over 
        # and parse the "pretty" URL (like /wp-admin/ or /my-post/) to determine what content to serve.
        location / {
            try_files $uri $uri/ /index.php?$args;
            # This means: try file, then try directory, then pass to index.php
        }
    }
}


###### DIO PROBLEMAS

# user                            www;  # Runs Nginx workers as a non-privileged user.
# worker_processes                auto; # it will be determinate automatically by the number of core.
# daemon                          off;  # Enable the master process to run in the foreground.
# error_log                       /var/log/nginx/error.log debug; # warn is a reasonable level for production.
# #pid                             /var/run/nginx/nginx.pid; # it permit you to use rc-service nginx reload|restart|stop|start.

# # worker_connections set the maximum number of simultaneous active connections that a single worker process can handle
# # multi_accept on forces worker to accept all pending connections on the listener socket, instead of only one connection at a time
# # (multi_accept off).It essentially "drains" the queue of waiting connections in a single go. No impact in academic exercise
# events {
#     worker_connections          1024; # Reduced for academic exercise/lower RAM needs
#     multi_accept on;
# }

# http {
#     include                     /etc/nginx/mime.types;
#     default_type                application/octet-stream;
#     sendfile                    on;
#     access_log                  /var/log/nginx/access.log;
#     keepalive_timeout           3000;

#     # to force all HTTP traffic to HTTPS
#     server {
#         listen 80;
#         listen [::]:80;
#         server_name localhost luicasad.42.fr;
#         return 301 https://$host$request_uri;
#     }      

#     server {
#         listen                  443 ssl; # Listen for HTTPS on port 443
#         listen                  [::]:443 ssl; # Listen on IPv6 as well

#         ssl_certificate         /etc/nginx/ssl/nginx.crt;      # Path to certificate inside the container
#         ssl_certificate_key     /etc/nginx/ssl/nginx.key;      # Path to private key inside the container

#         ssl_protocols           TLSv1.2 TLSv1.3;
#         ssl_ciphers             HIGH:!aNULL:!MD5;
#         #ssl_ciphers              'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305';
#         #ssl_prefer_server_ciphers on; # Ensures server's preferred ciphers are used

#         root                    /www; # Where your index.html or index.php is located
#         index                   index.php index.html index.htm; 
#         # Placing index.php first ensures that if a directory is requested and 
#         # both index.php and index.html (or other index files) exist within that directory, 
#         # WordPress's index.php is always given precedence and executed, allowing WordPress 
#         # to take control of the request and render the appropriate dynamic content.
#         server_name             localhost luicasad.42.fr; 
#         client_max_body_size    8m; # match post_max_size in php.ini to Preventing Resource Exhaustion (DoS Protection):  

        
#         # --------------------------------------------------------------------
#         # IMPORTANT: Static files MUST be handled BEFORE the location / block
#         # --------------------------------------------------------------------
#         location ~* \.(css|js|gif|jpe?g|png|woff|woff2|ttf|eot|svg|ico)$ {
#             expires 30d; # Cache for a month
#             add_header Cache-Control "public, no-transform";
#             try_files $uri =404; # Serve file directly or 404
#             # Add this to prevent accidental redirects or internal processing
#             # It should already be handled by try_files but good to be explicit
#             access_log on; # Turn off access logging for static files
#             log_not_found on; # Don't log 404s for static files in error.log
#         }

#         # --------------------------------------------------------------------
#         # PHP files MUST be handled BEFORE the general location / block
#         # --------------------------------------------------------------------

#         # You'd typically use ~* when you want to handle file extensions or parts of a URL 
#         # without worrying about the client's capitalization.
#         # ~*: This is the operator for a case-insensitive regular expression match. either .php or . PHP
#         # ~ : This is the operator for a case-  sensitive regular expression match. only .php
#         location ~* \.php$ {
#         # Ensure the file exists before passing to PHP-FPM
#         try_files $uri =404;

#         # Forward requests to the contentserver container's IP and PHP-FPM port
#         fastcgi_pass 192.168.1.3:9000;

#         # Include standard FastCGI parameters
#         include fastcgi_params;

#         # Set the SCRIPT_FILENAME to the actual path in the contentserver container
#         # This tells PHP-FPM the absolute path to the PHP script it needs to execute 
#         # within its own container. 
#         # $document_root will be /www
#         # $fastcgi_script_name will be the requested PHP file (e.g., /index.php).
#         fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
#         fastcgi_param PATH_INFO $fastcgi_path_info;
#         fastcgi_intercept_errors on; # Nginx handles error pages from FPM
#         fastcgi_read_timeout 60; # For WordPress, 60s is fine, increase for long-running scripts.
#         }

#         # --------------------------------------------------------------------
#         # WordPress Permalinks / General Fallback - This must be LAST
#         # --------------------------------------------------------------------

#         # This is the crucial line for WordPress permalinks
#         # $uri: Nginx first tries to serve the request as a literal file 
#         # (e.g., if you request /image.jpg, it looks for /www/image.jpg).
#         # $uri/: If $uri isn't found, Nginx then tries to serve it as a directory 
#         # (e.g., if you request /my-folder/, it looks for /www/my-folder/index.html or index.php based on index directive).
#         # /index.php?$args;: If neither a direct file nor a directory is found, Nginx internally redirects the request 
#         # to /index.php and passes all original query arguments (?$args). This is what allows WordPress to take over 
#         # and parse the "pretty" URL (like /wp-admin/ or /my-post/) to determine what content to serve.
#         location / {
#             try_files $uri $uri/ /index.php?$args;
#             # This means: try file, then try directory, then pass to index.php
#         }

#         location ~ /\.ht {
#             deny all;
#         }
#         # Optional: Deny access to wp-config.php and other sensitive files
#         # This block is missing from your current config, but was in previous examples.
#         # It's a good security addition.
#         location ~ /(wp-config\.php|wp-app\.php|wp-settings\.php|wp-comments-post\.php|wp-links-opml\.php|wp-load\.php|wp-mail\.php|xmlrpc\.php|install\.php|wp-cron\.php$) {
#             deny all;
#         }

#         error_page 404 /page_not_found.html; # Single definition
#         error_page 497 =400 /bad_request_ssl.html;
#         error_page 500 502 503 504 /50x.html;

#         location = /page_not_found.html {
#             root /www; # Assuming your custom 404 page is in your web root
#             internal;
#         }

#         location = /bad_request_ssl.html {
#             root /www; # Assuming your custom 497 page is in your web root
#             internal;
#         }

#         location = /50x.html {
#             root /www; # Assuming your custom 50x page is in your web root
#             internal;
#         }
     
#         }
#     }
# }

